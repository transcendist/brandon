-- Brandon Database Schema
-- Run this SQL in your Supabase SQL Editor

-- ============================================
-- 1. User Roles Table
-- ============================================

CREATE TABLE IF NOT EXISTS user_roles (
  user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL CHECK (role IN ('admin', 'user')) DEFAULT 'user',
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_user_roles_user ON user_roles(user_id);

-- Enable Row Level Security
ALTER TABLE user_roles ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can read own role" ON user_roles;
DROP POLICY IF EXISTS "Service role can manage roles" ON user_roles;

-- Users can read their own role
CREATE POLICY "Users can read own role"
  ON user_roles FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

-- Service role can manage roles (for first-user-admin logic)
CREATE POLICY "Service role can manage roles"
  ON user_roles FOR ALL
  TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================
-- 2. Assets Table
-- ============================================

CREATE TABLE IF NOT EXISTS assets (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- File references (all optional - Brandon can be source of truth)
  dam_id text,
  file_name text,
  url text,

  -- Supabase Storage paths (generated by system)
  storage_path text NOT NULL,
  preview_path text NOT NULL,
  mime_type text,

  -- REQUIRED metadata
  usage_rights text NOT NULL CHECK (usage_rights IN ('internal_only', 'web_approved', 'print_approved', 'all_channels')),
  status text NOT NULL CHECK (status IN ('draft', 'approved', 'archived')) DEFAULT 'draft',
  image_purchase_date timestamptz NOT NULL,
  image_capture_date timestamptz NOT NULL,
  license_type_usage text NOT NULL,
  license_type_subscription text NOT NULL,

  -- OPTIONAL metadata
  partner text,
  client text,
  brand text,
  collection text,
  region_representation text,
  location text,
  campaign text,

  -- LLM-generated content
  llm_description text NOT NULL,
  llm_metadata jsonb,
  tags text[],

  -- Legacy/optional
  acquired_at timestamptz,

  -- Audit
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  created_by uuid REFERENCES auth.users(id)
);

CREATE INDEX IF NOT EXISTS idx_assets_status ON assets(status);
CREATE INDEX IF NOT EXISTS idx_assets_purchase_date ON assets(image_purchase_date DESC);
CREATE INDEX IF NOT EXISTS idx_assets_brand ON assets(brand);
CREATE INDEX IF NOT EXISTS idx_assets_region ON assets(region_representation);

-- Enable Row Level Security
ALTER TABLE assets ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Authenticated users can read approved assets" ON assets;
DROP POLICY IF EXISTS "Admins can read all assets" ON assets;
DROP POLICY IF EXISTS "Admins can insert assets" ON assets;
DROP POLICY IF EXISTS "Admins can update assets" ON assets;
DROP POLICY IF EXISTS "Admins can delete assets" ON assets;
DROP POLICY IF EXISTS "Service role can manage assets" ON assets;

-- All authenticated users can read approved assets
CREATE POLICY "Authenticated users can read approved assets"
  ON assets FOR SELECT
  TO authenticated
  USING (status = 'approved');

-- Admins can read all assets
CREATE POLICY "Admins can read all assets"
  ON assets FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Admins can insert assets
CREATE POLICY "Admins can insert assets"
  ON assets FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Admins can update assets
CREATE POLICY "Admins can update assets"
  ON assets FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Admins can delete assets
CREATE POLICY "Admins can delete assets"
  ON assets FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Service role can manage all assets (for ingestion)
CREATE POLICY "Service role can manage assets"
  ON assets FOR ALL
  TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================
-- 3. Chat Messages Table
-- ============================================

CREATE TABLE IF NOT EXISTS chat_messages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL CHECK (role IN ('user', 'assistant')),
  content text NOT NULL,
  assets jsonb,
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_chat_messages_user_created ON chat_messages(user_id, created_at DESC);

-- Enable Row Level Security
ALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can read own messages" ON chat_messages;
DROP POLICY IF EXISTS "Users can insert own messages" ON chat_messages;
DROP POLICY IF EXISTS "Users can delete own messages" ON chat_messages;

-- Users can only read their own messages
CREATE POLICY "Users can read own messages"
  ON chat_messages FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

-- Users can only insert their own messages
CREATE POLICY "Users can insert own messages"
  ON chat_messages FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- Users can delete their own messages (for clear history)
CREATE POLICY "Users can delete own messages"
  ON chat_messages FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

-- ============================================
-- 4. Storage Buckets and Policies
-- ============================================

-- Note: Run these in the Supabase Dashboard > Storage section
-- or use the Supabase Management API

-- Create buckets (if not exists)
INSERT INTO storage.buckets (id, name, public)
VALUES
  ('assets-full', 'assets-full', false),
  ('assets-preview', 'assets-preview', false)
ON CONFLICT (id) DO NOTHING;

-- Drop existing policies
DROP POLICY IF EXISTS "Admins can upload full images" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can view full images" ON storage.objects;
DROP POLICY IF EXISTS "Admins can upload preview images" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can view preview images" ON storage.objects;

-- RLS policies for assets-full bucket
CREATE POLICY "Admins can upload full images"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (
    bucket_id = 'assets-full' AND
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Authenticated users can view full images"
  ON storage.objects FOR SELECT
  TO authenticated
  USING (bucket_id = 'assets-full');

-- RLS policies for assets-preview bucket
CREATE POLICY "Admins can upload preview images"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (
    bucket_id = 'assets-preview' AND
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Authenticated users can view preview images"
  ON storage.objects FOR SELECT
  TO authenticated
  USING (bucket_id = 'assets-preview');

-- ============================================
-- 5. Functions and Triggers
-- ============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS update_assets_updated_at ON assets;

-- Trigger to automatically update updated_at
CREATE TRIGGER update_assets_updated_at
    BEFORE UPDATE ON assets
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
